---
title: "Categorical Data"
description: "This vignette covers the use of zonal with categorical data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Categorical Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---





```r
library(zonal)
library(ggplot2)
library(dplyr)
```

In `zonal` categorical data is handled with `execute_zonal_cat` which computes the relative proportion of a numeric class in each aggregation unit. In the following we illustrate its use using a mosaiced 1km grid containing MODIS 2019 land cover.

### Grid

```r
file = '/Users/mjohnson/Downloads/MCD12Q1.006.nc'
(r = raster::raster(file))
#> class      : RasterLayer 
#> dimensions : 2896, 4616, 13367936  (nrow, ncol, ncell)
#> resolution : 1000, 1000  (x, y)
#> extent     : -2357000, 2259000, 277000, 3173000  (xmin, xmax, ymin, ymax)
#> crs        : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +ellps=clrk66 +units=m +no_defs 
#> source     : /Users/mjohnson/Downloads/MCD12Q1.006.nc 
#> names      : LCType1 
#> z-value    : 17897 
#> zvar       : LCType1
```

Looking at the grid we can see in consists of 1.3367936 &times; 10<sup>7</sup> grid cells each with a 1000 meter by 1000 meter resolution. Additionally, there are 18 unique values in the grid (17 landcover and one nodata value).

### Example 1: Basic Use

First, we want to identify the percent of each land cover within each county in the USA Northeast. Doing this follows the same process as all `zonal` workflows and requires (1) identifiying the aggregation units, (2) building a weight grid and (3) running the intersection.

#### Define aggreation units


```r
AOI  = AOI::aoi_get(state = "Northeast", county = "all")
plot(AOI$geometry, main = paste(nrow(AOI), "counties"))
```

![plot of chunk unnamed-chunk-8](figure/unnamed-chunk-8-1.png)

#### Build a weight grid and execute intersection


```r
system.time({
  w  = weighting_grid(file, AOI, "name")
  lc = execute_zonal_cat(file, w)
})
#>    user  system elapsed 
#>    2.26    0.60    2.14

glimpse(lc)
#> Rows: 1,664
#> Columns: 3
#> $ name       [3m[38;5;246m<chr>[39m[23m "Aroostooâ€¦
#> $ value      [3m[38;5;246m<int>[39m[23m 8, 10, 13â€¦
#> $ percentage [3m[38;5;246m<dbl>[39m[23m 0.1334921â€¦
```
#### Exploring the data


```r
to_plot = merge(AOI, lc)

{plot(filter(to_plot, value == 5)['percentage'], border = "NA", main = "Mixed Forest", reset = FALSE)
 plot(AOI::aoi_get(state = "Northeast")$geometry, add = TRUE)}
```

![plot of chunk unnamed-chunk-10](figure/unnamed-chunk-10-1.png)

```r

{plot(filter(to_plot, value == 13)['percentage'], border = "NA", main = "Urban", reset = FALSE)
  plot(AOI::aoi_get(state = "Northeast")$geometry, add = TRUE)}
```

![plot of chunk unnamed-chunk-10](figure/unnamed-chunk-10-2.png)

### Example 2: Definining Classes 

While the above works, callinging on fields by there numeric ID is prone to error. Instead, this example shows how a reclassification table can be supplied to modify the column headings of the output table.

#### Define Aggregation Units


```r
AOI  = AOI::aoi_get(state = "North Central", county = "all")
plot(AOI$geometry, main = paste(nrow(AOI), "counties"))
```

![plot of chunk unnamed-chunk-11](figure/unnamed-chunk-11-1.png)
#### Define Reclass Table

A reclassification table tells us what each numeric value represents in a categorical raster. Below, we use a CSV file to define this mapping. The schema used is that one column must be named "from" - this is the exisiting data values, and one column must be named "to" - this is the desired column headings.


```r
rcl = read.csv("../inst/modis_lc.csv") %>% 
  dplyr::select(from = Class, to = short)

head(rcl)
#>   from               to
#> 1    1 evergreen_needle
#> 2    2  evergreen_broad
#> 3    3 deciduous_needle
#> 4    4  deciduous_broad
#> 5    5     mixed_forest
#> 6    6     closed_shrub
```

#### Build a weight grid and execute intersection


```r
system.time({
  # Build Weight Grid
  w  = weighting_grid(file, AOI, "geoid")
  # Intersect applying mapping
  lc = execute_zonal_cat(file, w, rcl)
})
#>    user  system elapsed 
#>   5.858   0.970   4.563

glimpse(lc)
#> Rows: 7,105
#> Columns: 3
#> $ geoid      [3m[38;5;246m<chr>[39m[23m "27077", â€¦
#> $ value      [3m[38;5;246m<chr>[39m[23m "woody_saâ€¦
#> $ percentage [3m[38;5;246m<dbl>[39m[23m 0.3552908â€¦
```

#### Explore the data


```r
midwest = merge(AOI, lc)
{plot(filter(midwest, value == 'croplands')['percentage'], main = "Croplands", border = 'NA', reset = FALSE)
  plot(AOI::aoi_get(state = "North Central")$geometry, add = TRUE)}
```

![plot of chunk unnamed-chunk-14](figure/unnamed-chunk-14-1.png)

```r

{plot(filter(midwest, value == 'urban')['percentage'], main = "Urban", border = 'NA', reset = FALSE)
  plot(AOI::aoi_get(state = "North Central")$geometry, add = TRUE)}
```

![plot of chunk unnamed-chunk-14](figure/unnamed-chunk-14-2.png)

### Further user-based aggregates

In the MODIS land cover scheme there are 5 classes loosly representing forest. If wanted to aggregate these to a single forest class, we can use the output `zonal` table.


```r
forest =filter(lc, grepl('forest|broad|needle', value)) %>% 
  group_by(geoid) %>% 
  summarise(forest = sum(percentage)) %>% 
  right_join(AOI) %>% 
  sf::st_as_sf()


{plot(forest['forest'], main = "Forest", border = 'NA', reset = FALSE)
  plot(AOI::aoi_get(state = "North Central")$geometry, add = TRUE)}
```

![plot of chunk unnamed-chunk-15](figure/unnamed-chunk-15-1.png)


## Comapre with exactextractr

From the `exactectractr` vignettes there is an example to compute class statisitcs using `dplyr`. Here we compare that appraoch, to one supplimented with `data.table`, to `zonal` with pre-compted weights, and to a single `zonal` execution.


```r
library(raster)
library(exactextractr)
library(data.table)

# exactextract with dplyr
exactextract_dplyr = function(file, AOI) {
  exact_extract(raster(file), AOI, function(df) {
  df %>%
    mutate(frac_total = coverage_fraction / sum(coverage_fraction)) %>%
    group_by(name, value) %>%
    summarise(freq = sum(frac_total), .groups = "keep")
}, summarize_df = TRUE, include_cols = "name", progress = FALSE)
}

# exactextract with data.table
exactextract_dt = function(file, AOI){
  exact_extract(raster(file), AOI, function(df) {
    dt = setDT(df)
    dt$frac_total = dt$coverage_fraction / sum(dt$coverage_fraction)
    dt[, .(freq = sum(frac_total, na.rm = TRUE)), by = .(name, value)]
  }, summarize_df = TRUE, include_cols = "name", progress = FALSE)
}

# pre-compute weights 
w = weighting_grid(file, AOI, "name")

bnch <- bench::mark(
  iterations = 1, check = FALSE, time_unit = "s",
  exactextract_dplyr  = exactextract_dplyr(file, AOI),
  exactextract_dt     = exactextract_dt(file, AOI),
  zonal_full          = execute_zonal_cat(file, w = weighting_grid(file, AOI, "name")),
  zonal_stage_weights = execute_zonal_cat(file, w)
)
```


<table class="table table-condensed">
 <thead>
  <tr>
   <th style="text-align:right;"> expression </th>
   <th style="text-align:right;"> medianTime </th>
   <th style="text-align:right;"> memoryAllocated </th>
   <th style="text-align:right;"> medianTime_rel </th>
   <th style="text-align:right;"> memoryAllocated_rel </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:right;"> zonal_stage_weights </td>
   <td style="text-align:right;"> 1.012143 </td>
   <td style="text-align:right;"> 554.750732MB </td>
   <td style="text-align:right;"> 1.000000 </td>
   <td style="text-align:right;"> 1.740559 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> zonal_full </td>
   <td style="text-align:right;"> 4.537179 </td>
   <td style="text-align:right;"> 1.572529GB </td>
   <td style="text-align:right;"> 4.482746 </td>
   <td style="text-align:right;"> 5.052303 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> exactextract_dt </td>
   <td style="text-align:right;"> 5.025951 </td>
   <td style="text-align:right;"> 501.532288MB </td>
   <td style="text-align:right;"> 4.965654 </td>
   <td style="text-align:right;"> 1.573583 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> exactextract_dplyr </td>
   <td style="text-align:right;"> 28.367905 </td>
   <td style="text-align:right;"> 318.719894MB </td>
   <td style="text-align:right;"> 28.027568 </td>
   <td style="text-align:right;"> 1.000000 </td>
  </tr>
</tbody>
</table>
